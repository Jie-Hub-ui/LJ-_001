/*******************************
		Linux mmap实现零拷贝
********************************/

1、传统IO
	基于传统的IO方式,底层实际上通过调用read()和write()来实现。
	通过read()把数据从硬盘读取到内核缓冲区,再复制到用户缓冲区;然后再通过write()写入到socket缓冲区,最后写入网卡设备。
	整个过程发生了4次用户态和内核态的上下文切换和4次拷贝,具体流程如下:
		1.用户进程通过read()方法向操作系统发起调用,此时上下文从用 户态转 向 内核态.
		2.DMA控制器把数据从硬盘中拷贝到读缓冲区.
		3.CPU把读缓冲区数据拷贝到应用缓冲区,上下文从内核态转为用户态,read()返回.
		4.用户进程通过write()方法发起调用,上下文从用户态转为内核态.
		5.CPU将应用缓冲区中数据拷贝到socket缓冲区.
		6.DMA控制器把数据从socket缓冲区拷贝到网卡,上下文从内核态切换回用户态,write()返回.
	用户态 & 内核态:用户空间指的就是用户进程的运行空间,内核空间就是内核的运行空间。如果进程运行在内核空间就是内核态,运行在用户空间就是用户态。
					为了安全起见,他们之间是互相隔离的,而在用户态和内核态之间的上下文切换也是比较耗时的。
	DMA拷贝:直接内存访问技术,本质上来说他就是一块主板上独立的芯片,通过它来进行内存和IO设备的数据传输,从而减少CPU的等待时间。
	
2、零拷贝
	零拷贝技术是指计算机执行操作时,CPU不需要先将数据从某处内存复制到另一个特定区域,这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。
	那么对于零拷贝而言,并非真的是完全没有数据拷贝的过程,只不过是减少用户态和内核态的切换次数以及CPU拷贝的次数。
	
	2.1 mmap内存映射
		mmap()函数在进程内存空间映射出一块区域,用于对应指定的一个文件,该内存区域上的数据与对应文件的数据一一对应,并在一开始用文件来初始化这片内存。
		主要实现方式是将读缓冲区的地址和用户缓冲区的地址进行映射,内核缓冲区和应用缓冲区共享,从而减少了从读缓冲区到用户缓冲区的一次CPU拷贝。
		#include <sys/mman.h>
		void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
			addr：指定映射的虚拟内存地址，可以设置为 NULL，让 Linux 内核自动选择合适的虚拟内存地址。
			length：映射的长度。
			prot：映射内存的保护模式，可选值如下：
				PROT_EXEC：可以被执行。
				PROT_READ：可以被读取。
				PROT_WRITE：可以被写入。
				PROT_NONE：不可访问。
			flags：指定映射的类型，常用的可选值如下：
				MAP_FIXED：使用指定的起始虚拟内存地址进行映射。
				MAP_SHARED：与其它所有映射到这个文件的进程共享映射空间(可实现共享内存)。
				MAP_PRIVATE：建立一个写时复制(Copy on Write)的私有映射空间。
				MAP_LOCKED：锁定映射区的页面,从而防止页面被交换出内存。
				...
			fd：进行映射的文件句柄。
			offset：文件偏移量（从文件的何处开始映射）。
		
		
	2.2 mmap + write
		整个过程发生了4次用户态和内核态的上下文切换和3次拷贝，具体流程如下：
			1.用户进程通过mmap()方法向操作系统发起调用,上下文从用户态转向内核态
			2.DMA控制器把数据从硬盘中拷贝到读缓冲区
			3.上下文从内核态转为用户态,mmap调用返回
			4.用户进程通过write()方法发起调用,上下文从用户态转为内核态
			5.CPU将读缓冲区中数据拷贝到socket缓冲区
			6.DMA控制器把数据从socket缓冲区拷贝到网卡,上下文从内核态切换回用户态,write()返回
		mmap的方式节省了一次CPU拷贝,同时由于用户进程中的内存是虚拟的,只是映射到内核的读缓冲区,所以可以节省一半的内存空间,比较适合大文件的传输。
		
	2.3 sendfile
		相比mmap来说,sendfile同样减少了一次CPU拷贝,而且还减少了2次上下文切换。
		#include <sys/sendfile.h>
		ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
		sendfile是Linux2.1内核版本后引入的一个系统调用函数,通过使用sendfile数据可以直接在内核空间进行传输,因此避免了用户空间和内核空间的拷贝,
			同时由于使用sendfile替代了read+write从而节省了一次系统调用,也就是2次上下文切换。
		整个过程发生了2次用户态和内核态的上下文切换和3次拷贝，具体流程如下：
			1.用户进程通过sendfile()方法向操作系统发起调用,上下文从用户态转向内核态
			2.DMA控制器把数据从硬盘中拷贝到读缓冲区
			3.CPU将读缓冲区中数据拷贝到socket缓冲区
			4.DMA控制器把数据从socket缓冲区拷贝到网卡,上下文从内核态切换回用户态,sendfile调用返回
		sendfile方法IO数据对用户空间完全不可见，所以只能适用于完全不需要用户空间处理的情况，比如静态文件服务器。



 ----------------------------------------
|     C++ 虚函数表及多态内部原理详解     |
 ----------------------------------------
 
	C++ 中的虚函数的作用主要是实现了多态的机制。关于多态,简而言之就是用父类型的指针指向其子类的实例,然后通过父类的指针调用实际子类的成员函数。
这种技术可以让父类的指针有"多种形态",这是一种泛型技术。

1、虚函数表
	每个含有虚函数的类都有一个虚函数表(Virtual Table)来实现的,简称为V-Table。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置
(这是为了保证取到的虚函数表有最高的性能——如果有多层继承或是多重继承的情况下)。这意味着我们通过对象实例的地址得到这张虚函数表,然后就可以遍历其中函数指针,
并调用相应的函数。
	1、每一个类都有虚函数列表。
	2、虚表可以继承,如果子类没有重写虚函数,那么子类虚表中仍然会有该函数的地址,只不过这个地址指向的是基类的虚函数实现。如果基类有3个虚函数那么基类的虚表中就有三项
		(虚函数地址),派生类也会有虚表,至少有三项;如果重写了相应的虚函数,那么虚表中的地址就会改变,指向自身的虚函数实现。如果派生类有自己的虚函数,那么虚表中就会添加该项。
	3、派生类的虚表中虚函数地址的排列顺序和基类的虚表中虚函数地址排列顺序相同,子类独有的虚函数放在后面。
	当定义一个有虚函数类的对象时,对象的第一块的内存空间就是一个指向虚函数列表的指针。

	假设我们有这样的一个类:
		class Base{
		public:
			virtual void f(){ cout <<　std::cout << "Base::f" << std::endl; }
			virtual void g(){ cout <<　std::cout << "Base::g" << std::endl; };
			virtual void h(){ cout <<　std::cout << "Base::h" << std::endl; };
		};
		
		typedef void(*Fun)(void);
		
		int main(int argc, char *argv[])
		{
			
			return 0;
		}
	
	
	
 ------------------------------------------------
|                谈谈c++右值引用                 |
|        原文位置：谈谈 C++ 的右值引用           |
 ------------------------------------------------
 
1、概述:什么是左值和右值？
	C/C++语言中可以放在赋值符号左边的变量,即具有对应的可以由用户访问的存储单元,并且能够由用户去改变其值的量。左值表示存储在计算机内存的对象,
而不是常量或计算的结果。或者说左值是代表一个内存地址值,并且通过这个内存地址,就可以对内存进行读并且写(主要是能写)操作;这也就是为什么左值可以被赋值的原因了。
相对应的还有右值:当一个符号或者常量放在操作符右边的时候,计算机就读取他们的"右值",也就是其代表的真实值。
	简单来说就是,左值相当于地址值,右值相当于数据值。右值指的是引用了一个存储在某个内存地址里的数据。

	左值右值翻译: 
	L-value中的L指的是Location,表示可寻址。Avalue (computer science)that has an address.    
	R-value中的R指的是Read,表示可读。in computer science, a value that does not have an address in a computer language.

	左值和右值是相对于赋值表达式而言的。左值是能出现在赋值表达式左边的表达式。左值表达式可以分为可读写的左值和只读左值。右值是可以出现在赋值表达式右边的表达式,
他可以是不占据内存空间的临时量或字面量,可以是不具有写入权的空间实体。如:
	int a = 3;         // a是左值
	const int b = 5;
	a = b + 2;         // a是左值,b+2是右值
	b = a+2;           //错！b是只读的左值但无写入权,不能出现在赋值符号左边
	(a = 4) += 28;     //a=4是左值表达式,28是右值,+=为赋值操作符
	34 = a + 2;        //错！34是字面量不能做左值
	
2、右值引用
	为了支持移动操作,c++新标准引入了一种新的引用类型—右值引用。所谓右值引用就是必须绑定到右值的引用。我们通过&&而不是&来获得右值引用。如我们将要看到的,
右值引用有一个重要的性质[只能绑定到一个将要销毁的对象]。因此,我们可以自由地将一个右值引用的资源"移动"到另一个对象中。
	一般而言,一个左值表达式表示的是一个对象的身份,而一个右值表达式表示的是对象的值。
	举例说明:
	int i = 42;
	int &r = i;            //正确,r引用i
	int &&rr = i           //错误,不能将一个右值引用绑定到一个左值上
	int &r2 = i*42;        //错误,i*42是一个右值
	const int &r3 = i*42;  //正确,我们可以将一个const的引用绑定到一个右值上
	int &&r2 = i*42;       //正确,将rr2绑定到乘法结果上
	
	2.1 左值持久,右值短暂
		左值有持久的状态,而右值要么是字面值常量,要么是表达式求值过程中创建的临时对象。
		由于右值引用只能绑定到临时对象,我们得知:
			(1)所引用的对象将要被销毁
			(2)该对象没有其他用户
		这两个特征意味着:使用右值引用的代码可以自由地接管所引用的对象的资源。
	2.2 变量是左值
		变量可以看作只有一个运算对象而没有运算符的表达式,虽然我们很少这样看待变量。类似于其他任何表达式,变量表达式也有左值/右值属性。变量表达式都是左值,
	带来的结果就是,我们不能将一个右值引用绑定到一个右值引用类型的变量上。
		int &&rr1 = 42;    //正确,字面值常量是右值
		int &&r2  = rr1;   //错误,表达式rr1是左值！
	注意:变量是左值,因此我们不能将一个右值引用直接绑定到一个变量上,即使这个变量是右值引用类型也不可以。	

3、标准库move函数
	虽然不能将一个右值引用直接绑定到一个左值上,但我们可以显式地将一个左值转换为对应的右值引用类型。我们可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用,
此函数定义在头文件utility中。
	int &&rr3 = std::move(rr1);  //OK
	move调用告诉编译器:我们有一个左值,但我们希望像右值一样处理它。我们必须认识到,调用move就意味着承诺:除了对rr1赋值或者销毁之外,我们将不再使用它。
在调用move之后,我们不能对移后源对象的值做任何假设。
	注意:
		1.我们可以销毁一个移后源对象,也可以赋予它新值,但是不能使用一个移后源对象的值。
		2.对于move的使用应该是std:move而不是move。这样做可以避免潜在的名字冲突.

4、无论声明一个左值引用还是右值引用,都必须立即初始化,而其原因可以理解为引用类型本身并不拥有所绑定对象的内存,
只是该对象的一个别名。左值引用是具名变量值得别名,右值引用则是不具名(匿名)变量的别名。

5、常量左值引用是个万能的引用，能够接受非常量左值、常量左值、右值对其进行初始化。
		
	
	
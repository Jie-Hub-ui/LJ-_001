1、C++ String操作
	1.beforeLast('(')    // 最后一个 '(' 前的内容
	2.beforeFirst('/')   // 第一个 '/' 前的内容
	3.afterLast('/')     // 最后一个'/'之后的内容
	4.afterFirst('/')    // 第一个'/'之后的内容
	5.str.afterLast('/').beforeLast('(')   // 最后一个'/'之后和最后一个'('之前之间的内容
	
	6.str.split("/" , ds , false)    // 将字符串str以 / 为分割，将分割后的内容依次存放在容器 ds 中
	7.str.split("/")                 // 查找字符串str中"/"字串的偏移位置
	
	8.小写的string转为char* ：c_str()
	9.大写的String转为char* : getCStr()
	

	10.String转std::string ------> ::toSTLString()
	11.std::string转String ------> ::toCFLString()

2、快速初始化成员变量
c++98 只能就地初始化为整型或枚举型的常量静态成员。
c++11 允许使用等号=或者花括号{}进行就地初始化非静态成员。
class test
{
public:
	int a = 10;
	int b {10};
};

3、产生死锁的条件
产生死锁的四个必要条件
	1.互斥条件：一个资源每次只能被一个进程使用
	2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
	3.不剥夺条件：进程已获得的资源，在未使用完之前，不得强行剥夺
	4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

4、C++继承中重载、覆盖、遮掩
重载特征:
	(1)具有相同的作用域(即同一个类定义中)
	(2)函数名字相同
	(3)参数类型，顺序 或 数目不同(包括const参数和非const函数)
	(4)virtual关键字可有可无
覆盖特征(派生类重新实现(或者改写)了基类的成员函数):
	(1)不同的作用域(非别位于派生类和基类中)
	(2)函数名称相同
	(3)参数列表完全相同
	(4)基类函数必须是虚函数
遮掩特征(指派生类的成员函数遮蔽了与其同名的基类成员函数):
	(1) 派生类的函数与基类的函数同名，但是参数列表有所差异。此时，不论有无virtual关键字，基类的函数在派生类中将被隐藏。(注意别与重载混合)
	(2)派生类的函数与基类的函数同名，参数列表也相同，但是基类函数没有virtual关键字。此时，基类的函数在派生类中将被吟唱。(注意别与覆盖混合)

5、引用与指针区别
（1）引用必须被初始化，指针可以不用初始化；
（2）引用初始化以后就不能被改变，而指针可以改变所指向的对象；
（3）不存在指向空值的引用，而指针可以指向一个空值。
（4）因为引用不能指向空值，这意味着使用引用之前不需要测试其合法性；而指针则需要经常进行测试。所以使用引用的代码效率要比使用指针的效率高，同时也使引用具有更高的安全性。

6、智能指针
	1、shared_ptr
		shared_ptr都有一个关联的计数器，通常称其为引用计数，无论何时我们拷贝一个shared_ptr，计数器都会递增。
	当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域）时，计数器就会递减，
	一旦一个shared_ptr的计数器变为0,它就会自动释放自己所管理的对象。
	智能指针陷阱：
	（1）不使用相同的内置指针值初始化（或reset）多个智能指针。
	（2）不delete get()返回的指针
	（3）不使用get()初始化或reset另一个智能指针
	（4）如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了
	（5）如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器


7、容器
list容器:又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，
		而不是必须存储在一整块连续的内存空间中。
